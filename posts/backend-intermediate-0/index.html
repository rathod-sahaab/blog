<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Bloom filters, the magic of O(1) indexes with rust | Everything Engineering</title>
<meta name=keywords content="backend,rust,low-level-design"><meta name=description content="Bloom filters are probabilistic data-structures, what that means it won’t be right all of the time but most of the time. Why would we use such a thing, cause it BLAZINGLY fast!! We will explore this with Rust cause it’s great and not as hard as you might think."><meta name=author content="Abhay"><link rel=canonical href=https://abhay.rs/blog/posts/backend-intermediate-0/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://abhay.rs/blog/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://abhay.rs/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://abhay.rs/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://abhay.rs/blog/apple-touch-icon.png><link rel=mask-icon href=https://abhay.rs/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css integrity=sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js integrity=sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><meta property="og:title" content="Bloom filters, the magic of O(1) indexes with rust"><meta property="og:description" content="Bloom filters are probabilistic data-structures, what that means it won’t be right all of the time but most of the time. Why would we use such a thing, cause it BLAZINGLY fast!! We will explore this with Rust cause it’s great and not as hard as you might think."><meta property="og:type" content="article"><meta property="og:url" content="https://abhay.rs/blog/posts/backend-intermediate-0/"><meta property="og:image" content="https://abhay.rs/blog/posts/backend-intermediate-0/posts/backend-intermediate-0/thumbnail-bi0.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-26T00:00:00+00:00"><meta property="article:modified_time" content="2023-11-26T00:00:00+00:00"><meta property="og:site_name" content="Everything Engineering"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://abhay.rs/blog/posts/backend-intermediate-0/posts/backend-intermediate-0/thumbnail-bi0.png"><meta name=twitter:title content="Bloom filters, the magic of O(1) indexes with rust"><meta name=twitter:description content="Bloom filters are probabilistic data-structures, what that means it won’t be right all of the time but most of the time. Why would we use such a thing, cause it BLAZINGLY fast!! We will explore this with Rust cause it’s great and not as hard as you might think."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://abhay.rs/blog/posts/"},{"@type":"ListItem","position":3,"name":"Bloom filters, the magic of O(1) indexes with rust","item":"https://abhay.rs/blog/posts/backend-intermediate-0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Bloom filters, the magic of O(1) indexes with rust","name":"Bloom filters, the magic of O(1) indexes with rust","description":"Bloom filters are probabilistic data-structures, what that means it won’t be right all of the time but most of the time. Why would we use such a thing, cause it BLAZINGLY fast!! We will explore this with Rust cause it’s great and not as hard as you might think.","keywords":["backend","rust","low-level-design"],"articleBody":"We will explore one simple and one Production-ish implementation of this with Rust cause it’s a great language and not as hard as you might think.\nI won’t dive into the history and mathematics of bloom filters, this wikipedia page does that great. I will be focusing more on intuition of how they work and how to make one. You can find the code at the backend-rs github repo\nSo without further adieu.\nProbably yes, definitely no. Bloom filter is used to “store” whether it has seen something already, similar to some applications where you would use HashSet, unorderd_map. When you ask it whether it has seen something it will respond with a yes or a no (boolean true/false).\nNo is straight forward, it has never seen the queried data. But, When it says yes, there’s a chance for false positive. That means bloom filter might say it has seen some data, which it in fact never saw.\nWhy would we use a bloom filters because it’s fast $ O(1) $ for already hashed data. So when bloom filters gives go ahead you can run expensive lookups like DB indexes $ O(log N) $ and others which give exact result. And in a situation when there are many No cases, that saves a lot of resources.\nThe contract In rust we represent contracts/interfaces with traits. Here we define a trait BloomFilter anything claiming to be a BloomFilter must implement these functions.\npub trait BloomFilter { fn insert(\u0026mut self, key: \u0026str); /// probably yes, definitely no. fn contains(\u0026self, key: \u0026str) -\u003e bool; } Here the key is a text we want to insert and later see if it was seen.\nExplain Rust Insert modifies the data in the data structure, flips bits etc. So it must modify some data in the data structure.\nfn insert(\u0026mut self, key: \u0026str); // ^ ^--- \u0026str: string reference* // +--- \u0026: reference, mut: modifies, self: this equivalent Contains should not modify data-structure, or else calling multiple times with same params will return different result\nfn contains(\u0026self, key: \u0026str) -\u003e bool; // ^ ^ ^--- true: probably yes, false: definitely no. // | |--- \u0026str: string reference* // +--- \u0026: reference, self: this equivalent // omitted mut as contains does not modify self Implementation Bloom filter are generally implemented as an array/vector of bits. I will use array of 32 booleans as an example.\npub struct BloomFilter32 { bits: [bool; 32], } hash function A hash function is a crucial component of most bloom filters, what a hash function does is it takes a lot of data and returns wildly smaller input data dependent output. A lot of information is lost in the process but, preserving data was never the aim, aim was to reduce the data so it is easy to process.\nA good hash function for bloom filters would have properties like:\nEven distribution. String sensitive. (order, case, etc. sensitive) Same result for same input. In our case hash function will take a string, and return a number between 0-31 (an index from our bits array). A simple hash function would be one that add all characters and mods them by 32. Let’s implement that.\n// v--- impl block, way to define methods/member function in rust impl BloomFilter32 { // v--- missing self, static function fn additive_hasher(key: \u0026str, seed: usize) -\u003e usize { // fold: // Produce one value from all characters key.chars().fold(0, |acc, ch| -\u003e usize { (acc + seed + (ch as usize % 32)) % 32 // modulo maths result 0-31 }) } } additive_hasher also takes a seed to be able to return different hash for same data, thanks to modulo mathematics. Which gives us a lot of different hash functions for next to no code!!\nimpl BloomFilter Insert:\nWhen we insert string, we ask our hash function for an index (data-dependent, evenly distributed, seemingly random). We mark our bit at that index as true/1. impl BloomFilter for BloomFilter32 { fn insert(\u0026mut self, key: \u0026str) { let hash = Self::additive_hasher(key, 0); self.bits[hash_a] = true; } Contains:\nWe are passed the string, so we again ask the hash function for an index (will be same for same data always). If the bit at given index is true that means same hash value was encountered before, we return true(probably yes). If the bit at given index is false that means same hash value was never encountered before ,we return false(definitely no). fn contains(\u0026self, key: \u0026str) -\u003e bool { let hash = Self::additive_hasher(key, 0); self.bits[hash] // \u003c-- no semicolon means return in rust } You might be wondering since the start why probably yes, definitely no. Because two different strings can have same hash value(index). So if an index is true, it means queried string or some other string which had the same value was seen.\nExample: Let’s say our hash function counts number of as in a string. Hash of hash(apple)=1, hash(banana) = 3, hash(mango)=1. So if bit at index 1 is true, it can be due to either apple or mango, so we can’t say for sure that apple was seen, apple was probably seen:\nTo minimise this false positives we use multiple hash functions which will give us different indexes.\nIn our example: hash_a_count(apple), hash_first_last_sum(apple) = 1, 6 (1 + 5) hash_a_count(mango), hash_first_last_sum(mango) = 1, 28 (13 + 15) hash_a_count(banana), hash_sum(banana) = 1, 3 (2 + 1)\nAs you can see the chance of collision is lowered. Adding that in code (remember our hasher takes a seed!).\nimpl BloomFilter for BloomFilter32 { fn insert(\u0026mut self, key: \u0026str) { let hash_a = Self::additive_hasher(key, 0); let hash_b = Self::additive_hasher(key, 1); self.bits[hash_a] = true; self.bits[hash_b] = true; } fn contains(\u0026self, key: \u0026str) -\u003e bool { let hash_a = Self::additive_hasher(key, 0); let hash_b = Self::additive_hasher(key, 1); self.bits[hash_a] \u0026\u0026 self.bits[hash_b] } } And that’s it our simple bloom filter is implemented.\nSimple bloom filter run test // ...imports fn main() { let mut bl = BloomFilter32::default(); bloomy(\u0026mut bl); } fn bloomy(bl: \u0026mut impl BloomFilter) { let keys = vec![\"mango\", \"apple\", \"orange\", \"banana\"]; // insert elements in bloom filter (using lambda function) keys.iter().for_each(|\u0026key| bl.insert(key)); // take(ref) ---^ ^use let mut test_keys = vec![\"carrot\", \"radish\", \"vegetable\", \"onion\"]; test_keys.extend(keys); let results = test_keys.iter().map(|\u0026key| bl.contains(key)); // ..code for ouput } Result\n+-----------+-------+ | carrot | false | +-----------+-------+ | radish | false | +-----------+-------+ | vegetable | false | +-----------+-------+ | onion | false | +-----------+-------+ | mango | true | +-----------+-------+ | apple | true | +-----------+-------+ | orange | true | +-----------+-------+ | banana | true | +-----------+-------+ You might have noticed our function bloomy doesn’t depend on BloomFilter32, and this is where interfaces shine and so does rust because rust does types best. We can replace BloomFilter32 with anything so let’s replace it with something good.\nProduction-ish implementation Now don’t go using BloomFilter32 in your production environment, there is more to bloom filters.\nData bits We used boolean to store our data bits, which wastes space as a boolean value takes 1 byte in memory. To fix this we will use bitvec crate for rust, which in effect stores 8 bits of accessible information per byte. We just tell bitvec how many bits we want and it takes care of the rest.\nuse bitvec::prelude::*; pub struct BloomFilterProd { bits: BitVec, hash_count: usize, } But how many bits do we want?\nBit count We used 32 bits of data for our bloom filter, now as we keep adding more elements, more and more of the bits will “on”. At one point all our bits will be filled and every query will return probably yes i.e. Rate of error will increase. This indicates us that the number of data bits depends on the number of elements we are planning to “store”. Think of it this way, the most amount of elements if every thing goes correctly is 32, each bit for presence of a distinct element.\nThere is a great proof on wikipedia page for the exact mathematics, the formula we will be using is $$ m = -n\\frac{\\log_2\\epsilon}{\\log2} $$\nm: number of bits n: max elements to store $ \\epsilon \\in [0, 1] $: Probability of false positive acceptable So our constructor must take $ n $ and $ \\epsilon $.\nIntuition m is linearly propotional to n, so more elements you need to store, the more bits you need. m is dependent on $ -\\log \\epsilon $ the more accuracy you want, the required bits will shoot up. Use a graph plotter. impl BloomFilterProd { // v--- constructor convention in rust, static function (new not required) pub fn new(elements: usize, false_probability: f32) -\u003e Self { let log2 = 2f32.ln(); // log(2) // m = -n * log2(p) / ln(2) let bit_count = -((elements as f32 * false_probability.log2()) / log2).ceil() as usize; // k = m/n * ln(2) let hash_count = (bit_count as f32 / elements as f32 * log2).ceil() as usize; Self { bits: bitvec![0; bit_count], hash_count, } // no semicolon, return } } hash function additive_hasher was sub-par to insult in short. seahash provides a better hasher, we will be keeping our wrapper so we can replace it in future also it’s easier to use this way.\nimpl BloomFilterProd { fn hash(\u0026self, key: \u0026str, seed: usize) -\u003e usize { let hash = seahash::hash_seeded(key.as_bytes(), seed as u64, 0, 0, 0) as usize; hash % self.bits.len() // get an index } } optimum hash function count The fewer hash functions you have, the more is the probability of two different inputs having the same hash so too few hash functions are not good. Increasing the number of hash functions activates more bits, but having too few bits relative to the number of hash functions can lead to nearly all bits being activated, which is not good.\nFormula for optimum hash count:\n$$ k = \\frac{m}{n} \\log 2 $$\nUnimportant Sidenote If you put the above derived value of m, meaning if you chose bits correctly hash functions count only depends on acceptable false_probability. $$ k = -\\frac{\\log_2\\epsilon}{\\log2^2} $$\nThese changes are already incorporated in constructor.\nimpl BloomFilter impl BloomFilter for BloomFilterProd { fn insert(\u0026mut self, key: \u0026str) { // v--- range in rust(easy for loops) for i in 0..self.hash_count { let hash = self.hash(key, i); // ^--- seed self.bits.set(hash, true) } } fn contains(\u0026self, key: \u0026str) -\u003e bool { // v--- return true if all invocations return true (0..self.hash_count).all(|i| { let hash = self.hash(key, i); self.bits[hash] }) } } Usage // ...imports fn main() { let mut bl = BloomFilterProd::new(10, 0.01); // let mut bl = BloomFilter32::default(); bloomy(\u0026mut bl); } // ...fn bloomy That’s it, one line changed. Power of interfaces.\n+-----------+-------+ | carrot | false | +-----------+-------+ | radish | false | +-----------+-------+ | vegetable | false | +-----------+-------+ | onion | false | +-----------+-------+ | mango | true | +-----------+-------+ | apple | true | +-----------+-------+ | orange | true | +-----------+-------+ | banana | true | +-----------+-------+ Conclusion We looked into what is a bloom filter and how to go around implementing one. We looked into intuition of what factors(number of elements, acceptable false probability) determine BloomFilter implementation(number of bits, hash_function count). Bloom filters save a lot of resources around the world look into them, and maybe use them.\n","wordCount":"1875","inLanguage":"en","image":"https://abhay.rs/blog/posts/backend-intermediate-0/posts/backend-intermediate-0/thumbnail-bi0.png","datePublished":"2023-11-26T00:00:00Z","dateModified":"2023-11-26T00:00:00Z","author":{"@type":"Person","name":"Abhay"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://abhay.rs/blog/posts/backend-intermediate-0/"},"publisher":{"@type":"Organization","name":"Everything Engineering","logo":{"@type":"ImageObject","url":"https://abhay.rs/blog/favicon.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://abhay.rs/blog accesskey=h title="Everything Engineering (Alt + H)"><svg style="margin-bottom:-.3em;border-radius:0" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs" width="30" height="30"><svg width="30" height="30" viewBox="0 0 99.682 99.682" xmlns="http://www.w3.org/2000/svg"><path d="M0 10.807v78.19h46.972V73.438H15.657V57.731h23.486v-15.61H15.657V26.416h31.315v-15.61zm99.682.0v78.19H52.71V73.438h31.315V57.731H60.539v-15.61h23.486V26.416H52.71v-15.61z" fill="currentcolor"/></svg><style>@media(prefers-color-scheme:light){:root{filter:none}}</style></svg>Everything Engineering</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://abhay.rs/blog/series/ title=series><span>series</span></a></li><li><a href=https://abhay.rs/blog/tags/ title=tags><span>tags</span></a></li><li><a href=https://abhay.rs title=abhay.rs><span>abhay.rs</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://abhay.rs/blog>Home</a>&nbsp;»&nbsp;<a href=https://abhay.rs/blog/posts/>Posts</a></div><h1 class=post-title>Bloom filters, the magic of O(1) indexes with rust</h1><div class=post-description>Bloom filters are probabilistic data-structures, what that means it won’t be right all of the time but most of the time. Why would we use such a thing, cause it BLAZINGLY fast!! We will explore this with Rust cause it’s great and not as hard as you might think.</div><div class=post-meta><span title='2023-11-26 00:00:00 +0000 UTC'>November 26, 2023</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1875 words&nbsp;·&nbsp;Abhay&nbsp;|&nbsp;<a href=https://github.com/rathod-sahaab/blog/edit/dev/content/posts/backend-intermediate-0/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://abhay.rs/blog/posts/backend-intermediate-0/thumbnail-bi0.png alt="Thumbnail: Probably yes, definitely no. - Bloom filters"><p>Bloom filters in a sentence.</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#probably-yes-definitely-no>Probably yes, definitely no.</a><ul><li><a href=#the-contract>The contract</a></li></ul></li><li><a href=#implementation>Implementation</a><ul><li><a href=#hash-function>hash function</a></li><li><a href=#impl-bloomfilter>impl BloomFilter</a></li></ul></li><li><a href=#production-ish-implementation>Production-ish implementation</a><ul><li><a href=#data-bits>Data bits</a></li><li><a href=#hash-function-1>hash function</a></li><li><a href=#impl-bloomfilter-1>impl BloomFilter</a></li><li><a href=#usage>Usage</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p>We will explore one simple and one Production-ish implementation of this with Rust cause it’s a great language and not as hard as you might think.</p><p>I won&rsquo;t dive into the history and mathematics of bloom filters, <a href=https://en.wikipedia.org/wiki/Bloom_filter>this wikipedia page</a> does that great. I will be focusing more on intuition of how they work and how to make one. You can find the code at the <a href=https://github.com/rathod-sahaab/backend-rs/tree/main/data-structures/bloom-filter/src>backend-rs github repo</a></p><p>So without further adieu.</p><h2 id=probably-yes-definitely-no>Probably yes, definitely no.<a hidden class=anchor aria-hidden=true href=#probably-yes-definitely-no>#</a></h2><p>Bloom filter is used to &ldquo;store&rdquo; whether it has seen something already, similar to some applications where you would use <code>HashSet</code>, <code>unorderd_map</code>.
When you ask it whether it has seen something it will respond with a yes or a no (boolean true/false).</p><p>No is straight forward, it has never seen the queried data.
But, When it says yes, there&rsquo;s a chance for false positive. That means bloom filter might say it has seen some data, which it in fact never saw.</p><p>Why would we use a bloom filters because it&rsquo;s fast $ O(1) $ for already hashed data. So when bloom filters gives go ahead you can run expensive lookups like DB indexes $ O(log N) $ and others which give exact result. And in a situation when there are many <strong>No</strong> cases, that saves a lot of resources.</p><h3 id=the-contract>The contract<a hidden class=anchor aria-hidden=true href=#the-contract>#</a></h3><p>In rust we represent contracts/interfaces with traits. Here we define a trait <code>BloomFilter</code> anything claiming to be a <code>BloomFilter</code> must implement these functions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>BloomFilter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>insert</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>key</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// probably yes, definitely no.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=k>fn</span> <span class=nf>contains</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>key</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Here the key is a text we want to insert and later see if it was seen.</p><details><summary>Explain Rust</summary><br><p>Insert modifies the data in the data structure, flips bits etc. So it must modify some data in the data structure.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>insert</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>key</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=c1>// ^             ^--- &amp;str: string reference*
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>          </span><span class=c1>// +--- &amp;: reference, mut: modifies, self: this equivalent
</span></span></span></code></pre></div><p>Contains should not modify data-structure, or else calling multiple times with same params will return different result</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>contains</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>key</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=c1>// ^             ^      ^--- true: probably yes, false: definitely no.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>          </span><span class=c1>// |             |--- &amp;str: string reference*
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>          </span><span class=c1>// +--- &amp;: reference, self: this equivalent
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>          </span><span class=c1>//         omitted mut as contains does not modify self
</span></span></span></code></pre></div></details><h2 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h2><p>Bloom filter are generally implemented as an array/vector of bits. I will use array of 32 booleans as an example.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>BloomFilter32</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>bits</span>: <span class=p>[</span><span class=kt>bool</span><span class=p>;</span><span class=w> </span><span class=mi>32</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=hash-function>hash function<a hidden class=anchor aria-hidden=true href=#hash-function>#</a></h3><p>A hash function is a crucial component of most bloom filters, what a hash function does is it takes a lot of data and returns wildly smaller input data dependent output. A lot of information is lost in the process but, preserving data was never the aim, aim was to reduce the data so it is easy to process.</p><p>A good hash function for bloom filters would have properties like:</p><ol><li>Even distribution.</li><li>String sensitive. (order, case, etc. sensitive)</li><li>Same result for same input.</li></ol><p>In our case hash function will take a string, and return a number between 0-31 (an index from our bits array).
A simple hash function would be one that add all characters and mods them by 32. Let&rsquo;s implement that.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// v--- impl block, way to define methods/member function in rust
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>impl</span><span class=w> </span><span class=n>BloomFilter32</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                     v---  missing self, static function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>additive_hasher</span><span class=p>(</span><span class=n>key</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>seed</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// fold:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>//    Produce one value from all characters
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>key</span><span class=p>.</span><span class=n>chars</span><span class=p>().</span><span class=n>fold</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=o>|</span><span class=n>acc</span><span class=p>,</span><span class=w> </span><span class=n>ch</span><span class=o>|</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>(</span><span class=n>acc</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>seed</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=p>(</span><span class=n>ch</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=mi>32</span><span class=p>))</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=mi>32</span><span class=w> </span><span class=c1>// modulo maths result 0-31
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>additive_hasher</code> also takes a seed to be able to return different hash for same data, thanks to modulo mathematics. Which gives us a lot of different hash functions for next to no code!!</p><h3 id=impl-bloomfilter>impl BloomFilter<a hidden class=anchor aria-hidden=true href=#impl-bloomfilter>#</a></h3><p>Insert:</p><ol><li>When we insert string, we ask our hash function for an index (data-dependent, evenly distributed, seemingly random).</li><li>We mark our bit at that index as true/1.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>BloomFilter</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>BloomFilter32</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>insert</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>key</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>hash</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span>::<span class=n>additive_hasher</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>bits</span><span class=p>[</span><span class=n>hash_a</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Contains:</p><ol><li>We are passed the string, so we again ask the hash function for an index (will be same for same data always).</li><li>If the bit at given index is true that means same hash value was encountered before, we return true(probably yes).</li><li>If the bit at given index is false that means same hash value was never encountered before ,we return false(definitely no).</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>contains</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>key</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>hash</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span>::<span class=n>additive_hasher</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>self</span><span class=p>.</span><span class=n>bits</span><span class=p>[</span><span class=n>hash</span><span class=p>]</span><span class=w> </span><span class=c1>// &lt;-- no semicolon means return in rust
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>You might be wondering since the start why probably yes, definitely no.
Because two different strings can have same hash value(index). So if an index is true, it means queried string or some other string which had the same value was seen.</p><p>Example:
Let&rsquo;s say our hash function counts number of <code>a</code>s in a string. Hash of <code>hash(apple)=1</code>, <code>hash(banana) = 3</code>, <code>hash(mango)=1</code>. So if bit at index <code>1</code> is true, it can be due to either <code>apple</code> or <code>mango</code>, so we can&rsquo;t say for sure that <code>apple</code> was seen, <code>apple</code> was probably seen:</p><p>To minimise this false positives we use multiple hash functions which will give us different indexes.</p><p>In our example:
<code>hash_a_count(apple), hash_first_last_sum(apple) = 1, 6 (1 + 5)</code>
<code>hash_a_count(mango), hash_first_last_sum(mango) = 1, 28 (13 + 15)</code>
<code>hash_a_count(banana), hash_sum(banana) = 1, 3 (2 + 1)</code></p><p>As you can see the chance of collision is lowered. Adding that in code (remember our hasher takes a seed!).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>BloomFilter</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>BloomFilter32</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>insert</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>key</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>hash_a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span>::<span class=n>additive_hasher</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>hash_b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span>::<span class=n>additive_hasher</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>bits</span><span class=p>[</span><span class=n>hash_a</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>bits</span><span class=p>[</span><span class=n>hash_b</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>contains</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>key</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>hash_a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span>::<span class=n>additive_hasher</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>hash_b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span>::<span class=n>additive_hasher</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>bits</span><span class=p>[</span><span class=n>hash_a</span><span class=p>]</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>bits</span><span class=p>[</span><span class=n>hash_b</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>And that&rsquo;s it our simple bloom filter is implemented.</p><h4 id=simple-bloom-filter-run-test>Simple bloom filter run test<a hidden class=anchor aria-hidden=true href=#simple-bloom-filter-run-test>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// ...imports
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>bl</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BloomFilter32</span>::<span class=n>default</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>bloomy</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>bl</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>bloomy</span><span class=p>(</span><span class=n>bl</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=n>BloomFilter</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>keys</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;mango&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;apple&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;orange&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;banana&#34;</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// insert elements in bloom filter (using lambda function)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>keys</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>for_each</span><span class=p>(</span><span class=o>|&amp;</span><span class=n>key</span><span class=o>|</span><span class=w> </span><span class=n>bl</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>key</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//         take(ref) ---^              ^use
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>test_keys</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;carrot&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;radish&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;vegetable&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;onion&#34;</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>test_keys</span><span class=p>.</span><span class=n>extend</span><span class=p>(</span><span class=n>keys</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>results</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>test_keys</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>map</span><span class=p>(</span><span class=o>|&amp;</span><span class=n>key</span><span class=o>|</span><span class=w> </span><span class=n>bl</span><span class=p>.</span><span class=n>contains</span><span class=p>(</span><span class=n>key</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ..code for ouput
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Result</p><pre tabindex=0><code>+-----------+-------+
| carrot    | false |
+-----------+-------+
| radish    | false |
+-----------+-------+
| vegetable | false |
+-----------+-------+
| onion     | false |
+-----------+-------+
| mango     | true  |
+-----------+-------+
| apple     | true  |
+-----------+-------+
| orange    | true  |
+-----------+-------+
| banana    | true  |
+-----------+-------+
</code></pre><p>You might have noticed our function <code>bloomy</code> doesn&rsquo;t depend on <code>BloomFilter32</code>, and this is where interfaces shine and so does rust because rust does types best. We can replace BloomFilter32 with anything so let&rsquo;s replace it with something good.</p><h2 id=production-ish-implementation>Production-ish implementation<a hidden class=anchor aria-hidden=true href=#production-ish-implementation>#</a></h2><p>Now don&rsquo;t go using <code>BloomFilter32</code> in your production environment, there is more to bloom filters.</p><h3 id=data-bits>Data bits<a hidden class=anchor aria-hidden=true href=#data-bits>#</a></h3><p>We used boolean to store our data bits, which wastes space as a boolean value takes 1 byte in memory. To fix this we will use <code>bitvec</code> crate for rust, which in effect stores 8 bits of accessible information per byte. We just tell <code>bitvec</code> how many bits we want and it takes care of the rest.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>bitvec</span>::<span class=n>prelude</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>BloomFilterProd</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>bits</span>: <span class=nc>BitVec</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>hash_count</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>But how many bits do we want?</p><h4 id=bit-count>Bit count<a hidden class=anchor aria-hidden=true href=#bit-count>#</a></h4><p>We used 32 bits of data for our bloom filter, now as we keep adding more elements, more and more of the bits will &ldquo;on&rdquo;. At one point all our bits will be filled and every query will return probably yes i.e. Rate of error will increase. This indicates us that the number of data bits depends on the number of elements we are planning to &ldquo;store&rdquo;.
Think of it this way, the most amount of elements if every thing goes correctly is 32, each bit for presence of a distinct element.</p><p>There is a great proof on wikipedia page for the exact mathematics, the formula we will be using is
$$
m = -n\frac{\log_2\epsilon}{\log2}
$$</p><ul><li><strong>m:</strong> number of bits</li><li><strong>n:</strong> max elements to store</li><li>$ \epsilon \in [0, 1] $: Probability of false positive acceptable</li></ul><p>So our constructor must take $ n $ and $ \epsilon $.</p><h5 id=intuition>Intuition<a hidden class=anchor aria-hidden=true href=#intuition>#</a></h5><ul><li>m is linearly propotional to n, so more elements you need to store, the more bits you need.<br></li><li>m is dependent on $ -\log \epsilon $ the more accuracy you want, the required bits will shoot up. Use a graph plotter.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>BloomFilterProd</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//       v--- constructor convention in rust, static function (new not required)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>elements</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>false_probability</span>: <span class=kt>f32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>log2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=k>f32</span><span class=p>.</span><span class=n>ln</span><span class=p>();</span><span class=w> </span><span class=c1>// log(2)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// m = -n * log2(p) / ln(2)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>bit_count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>-</span><span class=p>((</span><span class=n>elements</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>f32</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>false_probability</span><span class=p>.</span><span class=n>log2</span><span class=p>())</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>log2</span><span class=p>).</span><span class=n>ceil</span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// k = m/n * ln(2)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>hash_count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>bit_count</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>f32</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>elements</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>f32</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>log2</span><span class=p>).</span><span class=n>ceil</span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>bits</span>: <span class=nc>bitvec</span><span class=o>!</span><span class=p>[</span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=n>bit_count</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>hash_count</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=c1>// no semicolon, return
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=hash-function-1>hash function<a hidden class=anchor aria-hidden=true href=#hash-function-1>#</a></h3><p><code>additive_hasher</code> was sub-par to insult in short. <code>seahash</code> provides a better hasher, we will be keeping our wrapper so we can replace it in future also it&rsquo;s easier to use this way.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>BloomFilterProd</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>hash</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>key</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>seed</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>hash</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>seahash</span>::<span class=n>hash_seeded</span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=n>as_bytes</span><span class=p>(),</span><span class=w> </span><span class=n>seed</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>u64</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>hash</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>bits</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=c1>// get an index
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=optimum-hash-function-count>optimum hash function count<a hidden class=anchor aria-hidden=true href=#optimum-hash-function-count>#</a></h4><p>The fewer hash functions you have, the more is the probability of two different inputs having the same hash so too few hash functions are not good. Increasing the number of hash functions activates more bits, but having too few bits relative to the number of hash functions can lead to nearly all bits being activated, which is not good.</p><p>Formula for optimum hash count:</p><p>$$
k = \frac{m}{n} \log 2
$$</p><details><summary>Unimportant Sidenote</summary><p>If you put the above derived value of <strong>m</strong>, meaning if you chose bits correctly hash functions count only depends on acceptable <code>false_probability</code>.
$$
k = -\frac{\log_2\epsilon}{\log2^2}
$$</p></details><p>These changes are already incorporated in constructor.</p><h3 id=impl-bloomfilter-1>impl BloomFilter<a hidden class=anchor aria-hidden=true href=#impl-bloomfilter-1>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>BloomFilter</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>BloomFilterProd</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>insert</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>key</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//        v--- range in rust(easy for loops)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=o>..</span><span class=bp>self</span><span class=p>.</span><span class=n>hash_count</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>hash</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>//                        ^--- seed
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>bits</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=n>hash</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>contains</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>key</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//                    v--- return true if all invocations return true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=p>(</span><span class=mi>0</span><span class=o>..</span><span class=bp>self</span><span class=p>.</span><span class=n>hash_count</span><span class=p>).</span><span class=n>all</span><span class=p>(</span><span class=o>|</span><span class=n>i</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>hash</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>bits</span><span class=p>[</span><span class=n>hash</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=usage>Usage<a hidden class=anchor aria-hidden=true href=#usage>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// ...imports
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>bl</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BloomFilterProd</span>::<span class=n>new</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=w> </span><span class=mf>0.01</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// let mut bl = BloomFilter32::default();
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>bloomy</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>bl</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ...fn bloomy
</span></span></span></code></pre></div><p>That&rsquo;s it, one line changed. Power of interfaces.</p><pre tabindex=0><code>+-----------+-------+
| carrot    | false |
+-----------+-------+
| radish    | false |
+-----------+-------+
| vegetable | false |
+-----------+-------+
| onion     | false |
+-----------+-------+
| mango     | true  |
+-----------+-------+
| apple     | true  |
+-----------+-------+
| orange    | true  |
+-----------+-------+
| banana    | true  |
+-----------+-------+
</code></pre><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>We looked into what is a bloom filter and how to go around implementing one. We looked into intuition of what factors(number of elements, acceptable false probability) determine BloomFilter implementation(number of bits, hash_function count). Bloom filters save a lot of resources around the world look into them, and maybe use them.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://abhay.rs/blog/tags/backend/>backend</a></li><li><a href=https://abhay.rs/blog/tags/rust/>rust</a></li><li><a href=https://abhay.rs/blog/tags/low-level-design/>low-level-design</a></li></ul><nav class=paginav><a class=next href=https://abhay.rs/blog/posts/payments-system-0/><span class=title>Next »</span><br><span>Building a Modular and Extensible Payments System [0]</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Bloom filters, the magic of O(1) indexes with rust on x" href="https://x.com/intent/tweet/?text=Bloom%20filters%2c%20the%20magic%20of%20O%281%29%20indexes%20with%20rust&amp;url=https%3a%2f%2fabhay.rs%2fblog%2fposts%2fbackend-intermediate-0%2f&amp;hashtags=backend%2crust%2clow-level-design"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Bloom filters, the magic of O(1) indexes with rust on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fabhay.rs%2fblog%2fposts%2fbackend-intermediate-0%2f&amp;title=Bloom%20filters%2c%20the%20magic%20of%20O%281%29%20indexes%20with%20rust&amp;summary=Bloom%20filters%2c%20the%20magic%20of%20O%281%29%20indexes%20with%20rust&amp;source=https%3a%2f%2fabhay.rs%2fblog%2fposts%2fbackend-intermediate-0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Bloom filters, the magic of O(1) indexes with rust on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fabhay.rs%2fblog%2fposts%2fbackend-intermediate-0%2f&title=Bloom%20filters%2c%20the%20magic%20of%20O%281%29%20indexes%20with%20rust"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Bloom filters, the magic of O(1) indexes with rust on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fabhay.rs%2fblog%2fposts%2fbackend-intermediate-0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Bloom filters, the magic of O(1) indexes with rust on whatsapp" href="https://api.whatsapp.com/send?text=Bloom%20filters%2c%20the%20magic%20of%20O%281%29%20indexes%20with%20rust%20-%20https%3a%2f%2fabhay.rs%2fblog%2fposts%2fbackend-intermediate-0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Bloom filters, the magic of O(1) indexes with rust on telegram" href="https://telegram.me/share/url?text=Bloom%20filters%2c%20the%20magic%20of%20O%281%29%20indexes%20with%20rust&amp;url=https%3a%2f%2fabhay.rs%2fblog%2fposts%2fbackend-intermediate-0%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Bloom filters, the magic of O(1) indexes with rust on ycombinator" href="https://news.ycombinator.com/submitlink?t=Bloom%20filters%2c%20the%20magic%20of%20O%281%29%20indexes%20with%20rust&u=https%3a%2f%2fabhay.rs%2fblog%2fposts%2fbackend-intermediate-0%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://abhay.rs/blog>Everything Engineering</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>